"use strict";

var utils = require("../utils");
var log = require("npmlog");

module.exports = function (http, api, ctx) {
  return function markAsRead(threadID, callback) {
    var cb;
    var rtPromise = new Promise(function (resolve, reject) {
      cb = (error) => error ? reject(error) : resolve();
    });

    if (typeof threadID == 'function') {
      callback = threadID;
      threadID = null;
    }
    if (typeof callback == 'function') cb = callback;
    if (typeof threadID != 'string') {
      log.error('markAsRead', 'threadID must be string');
      return cb('threadID must be string');
    }
    if (!ctx.mqttClient) {
      log.error('markAsRead', 'You can only use this function after you start listening.');
      return cb('You can only use this function after you start listening.');
    }

    if (typeof ctx.globalOptions.pageID != 'undefined') {
      var form = {}
      form.source = "PagesManagerMessagesInterface";
      form.request_user_id = ctx.globalOptions.pageID;
      form["ids[" + threadID + "]"] = true;
      form.watermarkTimestamp = new Date().getTime();
      form.shouldSendReadReceipt = true;
      form.commerce_last_message_type = "";

      http
        .post(url, ctx.jar, form)
        .then(utils.saveCookies(ctx.jar))
        .then(utils.parseAndCheckLogin(ctx, http))
        .then(function (res) {
          if (res.error) {
            if (res.error == 'Not logged in.') ctx.loggedIn = false;
            throw res;
          }
          return cb();
        })
        .catch(function (err) {
          log.error('markAsRead', err);
          return cb(err);
        });
    } else {
      ctx.mqttClient
        .publish("/mark_thread", JSON.stringify({
          threadID,
          mark: "read",
          state: true
        }), { qos: 1, retain: false }, function (err, r) {
          if (err) {
            log.error('markAsRead', err);
            return cb(err);
          }
          return cb();
        });
    }

    return rtPromise;
  }
}